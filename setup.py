#!/usr/bin/env python
#
# Copyright (c) 2020 by:
# Kristoffer Paulsson <kristoffer.paulsson@talenten.se>
# This file is distributed under the terms of the MIT license.
#
"""Angelos build script."""
import distutils.command.build
import logging
import os
import re
import datetime
from glob import glob
from os import path

from setuptools import setup, Extension, Command

# FIXME: Translation process
#   Implement a setup command that handles the translation process
#   Document the translation process

base_dir = path.abspath(path.dirname(__file__))


class Translator(Command):
    """Translate texts in the project."""

    HEADER = """# This file was automatically generated by the translator command.\n# Timestamp: {}\n\n"""

    STRING = """{key} = _("{string}")\n"""

    MESSAGE = """#:\nmsgid "{identity}"\nmsgstr "{string}"\n\n"""

    user_options = [
    ]

    def initialize_options(self):
        """Initialize options"""
        pass

    def finalize_options(self):
        """Finalize options"""
        pass

    def run(self):
        """Loads the TEXTS and export them as gettext strings for the app."""
        TEXTS = None  # placeholder
        text_import = os.path.join(os.path.abspath(os.curdir), "lib", "logo", "texts.py")
        print("Loading the texts from {}".format(text_import))
        try:
            with open(text_import) as texts:
                imp_global = dict()
                exec(texts.read(), imp_global)
                if isinstance(imp_global, dict):
                    if "TEXTS" in imp_global.keys():
                        TEXTS = imp_global["TEXTS"]
                if not TEXTS:
                    raise ImportError("Failed importing TEXTS")
        except Exception as e:
            logging.error(e, exc_info=True)
            return

        text_export = os.path.join(os.path.abspath(os.curdir), "lib", "logo", "strings.py")
        print("Writing the gettext strings to {}".format(text_export))
        try:
            with open(text_export, "w+") as strings:
                strings.write(self.HEADER.format(datetime.datetime.now()))
                for key in TEXTS:
                    strings.write(self.STRING.format(key=key, string=repr(TEXTS[key])[1:-1]))
        except Exception as e:
            logging.error(e, exc_info=True)

        pot_export = os.path.join(os.path.abspath(os.curdir), "assets", "locales", "messages.pot")
        print("Writing the pot message file to {}".format(pot_export))
        try:
            with open(pot_export, "w+") as strings:
                strings.write(self.HEADER.format(datetime.datetime.now()))
                for key in TEXTS:
                    message = repr(TEXTS[key])[1:-1]
                    strings.write(self.MESSAGE.format(identity=message, string=message))
        except Exception as e:
            logging.error(e, exc_info=True)


class BuildSetup(distutils.command.build.build):
    """Preparations and adaptions of building the app."""

    def run(self):
        """Carry out preparations and adaptions."""
        print("Before")
        distutils.command.build.build.run(self)
        print("After")


class LibraryScanner:
    """Scan directories for Cython *.pyx files and configure extensions to build."""

    def __init__(self, base_path: str, globlist: list = None, pkgdata: dict = None, data: dict = None):
        self.__base_path = base_path
        self.__globlist = globlist if globlist else ["**.pyx"]
        self.__pkgdata = pkgdata if pkgdata else {}
        self.__data = data if data else {
            "compiler_directives": {
                "language_level": 3,
                "embedsignature": True
            }
        }

    def scan(self) -> list:
        """Build list of Extensions to be cythonized."""
        glob_result = list()
        for pattern in self.__globlist:
            glob_path = os.path.join(self.__base_path, pattern)
            glob_result += glob(glob_path, recursive=True)

        extensions = list()
        for module in glob_result:
            package = re.sub("/", ".", module[len(self.__base_path) + 1:-4])
            data = self.__pkgdata[package] if package in self.__pkgdata else {}
            core = {"name": package, "sources": [module]}
            kwargs = {**self.__data, **data, **core}
            extensions.append(Extension(**kwargs))

        return extensions


with open(os.path.join(base_dir, "README.md")) as desc:
    long_description = desc.read()

with open(os.path.join(base_dir, "version.py")) as version:
    exec(version.read())

setup(
    cmdclass={
        "build": BuildSetup,
        "translate": Translator
    },
    name="logo",
    version=__version__,
    license="MIT",
    description="A safe messaging system",
    author=__author__,
    author_email=__author_email__,
    long_description=long_description,
    long_description_content_type="text/markdown",
    url=__url__,
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: End Users/Desktop",
        "License :: OSI Approved :: MIT License",
        "Topic :: Communications :: Chat",
        "Topic :: Communications :: Email",
        "Topic :: Communications :: File Sharing",
        "Topic :: Religion",
        "Topic :: Security",
    ],
    zip_safe=True,
    python_requires="~=3.7",
    setup_requires=["cython", "pyinstaller"],
    install_requires=["kivy", "kivymd", "libangelos"],
        # git+https://github.com/kristoffer-paulsson/angelos.git
    packages=["logo"],
    package_dir={"": "lib"},
    scripts=glob("bin/*"),
    # ext_modules=cythonize(LibraryScanner("lib", globlist, pkgdata, coredata).scan())
)
